# 前端面试题
---

## web前端优化
> * JS/CSS：
        JS会阻塞页面渲染，放在页面最下方；
        CSS在页面顶部加载。避免CSS表达式
        合并重用相同的代码块，对文件进行合并压缩，减少HTTP请求数
> * 图片：合并压缩图片，减少HTTP请求数
> * 页面优化：
        结构语义化，优化body里面的标签
        优化 `title`， `description`， `keywords` 等
> * 服务端：
        开启 `gzip` / `bzip2` 压缩
        使用HTTP的`keep-alive`减少连接数
        开启 `Etags`，实体标签，进行页面缓存
        开启 `APC`， `opcode` 缓存
        `memcache` / `redis` 数据缓存
        代码优化

---  
## ajax跨域
> * 代理
> * `dataTpye: "jsonp"`
> * `header("Access-Control-Allow-Origin:*");`
> * jquery  `getJson()`

---
## 事件捕获/事件冒泡
* 捕获由父级到子级
* 冒泡由子级到父级  
``` element.addEventListener(event, function, useCapture); ```    

> `useCapture`  
> true - 事件句柄在捕获阶段执行    
> false- false- 默认。事件句柄在冒泡阶段执行    

* 事件按顺序绑定

---
## 事件委托/事件绑定
* 委托在处理速度和内存占用上都优于事件绑定
* 但委托会在事件冒泡中造成性能损失  

> 委托对未来元素有效，事件绑定只对当前已有元素有效，对脚本后来生成的元素无效

``` on > delegate > live > bind ```   

> * `bind` 直接绑定，只对现有元素有效
> * `live` 通过冒泡匹配到对应的元素，对未来有效
> * `delegate` 相对于 `live` 更精确
> * `on` 是以上几种的综合体  

---  
## 立即执行函数  
``` (function(){}()) ```  
``` (function(){})() ```  
只用于函数表达式  例：  
``` var kof = function(){}() ```  
> 可以模仿出一个私有作用域，不会遗留全局变量，不会污染全局空间，用于JS模块化编程，又被称作“匿名包裹器”、“命名空间”  

---  
## 阻止冒泡  
> * ``` return false ```  
> * ``` event.target == event.currentTarget ```    
> * ``` event.stopPropagation ```    
> * ``` event.preventDefault ```    

---  
## 为什么使用闭包  
> 进行信息的隐藏和封装，模拟一些 OO 的特性，避免变量污染  

---  
## 变量提升（Hoisting）   
> 会将变量声明过程提升到顶部  
``` javascript  
    var a = 6;
    setTimeout(function () {
        alert(a);
        var a = 666;
    }, 1000);
    a = 66;  
    // undefined    
```   

---  
## 延迟加载  
**`setTimeout()` / `clearTimeout()`**  
> 加入到队列末执行  
``` javascript  
    var kof = 6;
    setTimeout(function () {
        alert(kof);
    }, 1000);
    a = 66;  
    // 66  
```
> 用于清除 jQuery 操作  

**`setInterval()` / `clearInterval()`**   
> 用于计时器操作  

---   
## 模块化编程思想  
> 模块化编程，低内聚，高耦合  
> 保证各模块之间的独立性，使各模块之间的依赖关系变的更加明确  
  
* 原始写法：  
``` javascript   
    function module () {
    
    }   
```  
> 污染全局变量，变量名可能冲突，各模块之间依赖关系不明确  

* 面向对象：  
``` javascript  
    var module = new Object({
        
    });  
```  
> 会暴露模块成员变量，能够从外部修改  

* 立即执行函数：  
``` javascript  
    var module = function () {
        var _sum = 0;
        var init = 100;
        
        var count = function () {
            return _sum + 1;
        };
        
        return {
            init: init;
            count: count;
        };
    }();  
```  
> 标准模块写法，只能访问 return 的值  

* 继承：  
``` javascript  
    var module = function (mod) {
        mod.k1 = function () {
        
        }();
        return mod;
    }(module);  
```    
* 防止空对象报错  
``` javascript  
    var module = function (mod) {
        mod.k1 = function () {
        
        }();
        return mod;
    }(module || {});  
```    
* 输入全局变量  
``` javascript  
    var module = function ($) {
        
    }(jQuery);  
```     
> 显示输入其他模块  

---   
## CommonJS 规范  
> 同步加载模块，如果模块太大会阻塞渲染  
`seaJS / CMD`  
  
---  
## AMD 规范  
> 异步模块定义  
> `require.js / curl.js`  
``` javascript  
    <script src="js/require.js" defer async="true"></script>  
```   
``` require([module], callback); ```

> `defer` : HTML4 中的异步加载
> `async` : HTML5 中的异步加载，不阻塞渲染  
   
---  
## JavaScript 数据类型 
**数据类型**
> * `boolean` —— 布尔值；
> * `string` —— 字符串；
> * `number` —— 数值；
> * `null` —— 空；
> * `object` —— 对象；
> * `undefined` —— 未定义；  

---  
> * `function` —— 函数；  
> * `array` —— 数组；  
> * `json` —— json；  
> * `NaN` —— 非法数字（not a number）
  
---  
## jsonp 原理    
> 利用<script>标签没有跨域限制的“漏洞”，来实现与第三方的通信  


---  
## 字符串转化   
> * `parseInt()` `parseFloat()`
    `return NaN / number`
> * `Boolean(value)` `Number(value)` `String(value)`   
> * `String.toString()`  
> * 利用 js 弱类型，使用算术运算，实现字符串到数字的类型转换    


---  
## XMLHttpRequest  
``` javascript  
    xmlhttp=null;
    if (window.XMLHttpRequest) {
        // code for all new browsers
        xmlhttp=new XMLHttpRequest();
    } else if (window.ActiveXObject) {
        // code for IE5 and IE6
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }  
```  

---  
## JavaScript 继承实现   
**原型继承**
> 实例既是父类的实例，又是子类的实例，但无法多重继承  
``` javascript  
    function Gizmo(id) {  
        this.id = id;  
    }  
    Gizmo.prototype.toString = function () {  
        return "gizmo " + this.id;  
    };  
    function Hoozit(id) {  
        this.id = id;  
    }  
    Hoozit.prototype = new Gizmo();  
    Hoozit.prototype.test = function (id) {  
        return this.id === id;  
    };    
```   
`Hoozit.prototype = new Gizmo();` 是原型继承的核心，把父类 `prototype` 赋给子类 `prototype` 

**`apply` `call`，重定向 `this`，实现继承**    
> 可以实现多重继承，但对象不是父类的实例
``` javascript   
    function Animal(name){    
        this.name = name;    
        this.showName = function(){    
            alert(this.name);    
        }    
    }    
    function Cat(name){  
        Animal.call(this, name);  
    }      
    var cat = new Cat("Black Cat");   
    cat.showName();  
```   
**实例继承**   
> 生成的对象实质仅仅是父类的实例，并非子类的对象；返回父类实例的一个扩充，不能多继承  
``` javascript  
    var Base = function () {
        this.level = 1;
        this.name = "base";
        this.toString = function () {
            return "base";
        };
    };
    Base.CONSTANT = "constant";
    var Sub = function () {
        var instance = new Base();
        instance.name = "sub";
        return instance;
    };  
```  
**自己定义继承函数**  
``` javascript  
    Function.method('inherits', function (parent) {

    });  
```  

---  
## this   
> 指向当前对象，使用 `call` `apply` 可以改变指向  

---  
##   动画算法    



---  
## 拖拽实现    


---  
## 熟悉的框架  


---  
## 模块化工具的特点    


---  
## JavaScript 压缩合并    



  
  
  
---  

---  
## CSS 模块化  
> 配合 `less / sass / stylus` 实现 css 的封装继承多态  

---  
## 定位  
> 不要总是用 `float`  
> `float` 后注意 `clear`  
> `position: relative;`   相对于前一个父级元素，用 `margin` 调整  
> `display: inline` / `inline-block`  

---  
## 标签比较  
`<b>` 与 `<strong>`, `<i>` 与 `<em>`  
> 一个是物理标签，一个是逻辑标签，前者强调的是物理行为，后者强调了当前环境的语义，更符合`标签语义化`，更符合w3c标准   

`<h1>` 与 `<title>`  
> SEO 时，`title` 权重高于 `h1`  

`<alt>` 与 `<title>`  
> `alt` 主要是为图像未加载时做的说明（只用于 `img` `area` `input`）  
> `title` 用于文字或链接加注释  
 
---  
## 双飞翼布局  
> 双飞翼布局：  
    1、三列布局，中间宽度自适应，两边定宽；  
    2、中间栏要在浏览器中优先展示渲染。    
``` html   
<style>
    .column { float: left; height: 200px; }
    .header { height: 50px; width: 100%; display: inline-block; background: #000; }
    .footer { height: 100px; width: 100%; display: inline-block; background: #000; }  
    #container { width: 100%; }
    #center_div { width: 100%; }
    #center_div #mainWrap { margin-left: 200px; margin-right: 220px; background: #abcdef; height: 100%; }
    #left_div { width: 200px; margin-left: -100%; background: #D1EB2F; }
    #right_div { width: 220px; margin-left: -220px; background: #ccc; }
</style>
<div class="header">header</div>
<div id="container">
    <div id="center_div" class="column">
        <div id="mainWrap">main</div>
    </div>
    <div id="left_div" class="column">left</div> 
    <div id="right_div" class="column">right</div>
</div>
<div class="footer">footer</div>     
```  

---  
## 圣杯布局  
> 圣杯布局：  
    1、三列布局，中间宽度自适应，两边定宽；  
    2、中间栏要在浏览器中优先展示渲染。   
    3、与双飞翼布局相比，使用 `relative` 定位，但少了一个 `div` 块
``` html  
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<style type="text/css">
    .main {       
        float: left;      
        width: 100%;  
        background: #39c;
        height: 300px;
     } 
    .sub {      
        float: left;       
        width: 200px;       
        margin-left: -100%;  
        background: #f60;
        height: 300px;
        position: relative;
        left: -200px;
    }  
    .extra {       
        float: left;       
        width: 220px;       
        margin-left: -230px;
        background: #666;
        height: 300px;
        position: relative;
        right: -230px;
    } 
    #bd {       
        padding: 0 220px 0 200px;  
    }
</style>
<div id="page">              
    <div id="hd">header</div>              
    <div id="bd">                   
        <div class="main">main</div>                
        <div class="sub">left</div>                   
        <div class="extra">right</div>       
    </div>          
    <div id="ft">footer</div>    
</div>   
```   

 
---  
## IE 某些兼容性问题  



---  
## CSS 合并方法    


---  
## 盒子模型    



---  
## CSS 动画原理   


---  

---  
## HTTP 状态码  


---  
## Cache-control    


---  
## 页面加载过程  


---  
## 前后端协同开发    


---  
## session  


---  
## 基础算法   




